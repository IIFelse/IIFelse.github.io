{"pages":[{"title":"About me","text":"想不到要写些什么才好，先这样","link":"/about/index.html"}],"posts":[{"title":"CSS-clear(清除浮动属性)","text":"网站的导航菜单布局已经成为web端页面设计‘饭后畅谈’的技术，对于横幅状排序，以各种技术参与到其中；比如常见的： css2.x 时代的 float 浮动布局, css3 的 flex 弹性布局；在本章中介绍的依然是‘烂大街’的浮动属性，那么对于浮动的介绍，前端人背的滚瓜烂熟的一套法则：《子元素为float元素，父元素高度默认情况下会发生坍塌现象；常规流中块盒元素在排列时，遇到浮动元素直接无视，行盒元素遇到浮动元素会自动跟随浮动元素》 在对网站页面导航进行浮动排序时，调试发现：父元素的 《默认高度》 参考子元素的 《内容高度》性质 失效 ，为什么会造成此因素，大家心里都清楚那套法则：是因为块盒默认无视浮动盒子的一切而无法计算出子元素的高度。 浏览器渲染规则时是按照循序渐进依次对元素进行渲染，在渲染到子元素的CSS属性时，发现此元素设置了float，所以将其进行浮动排序，而最终的结果就是：父元素依然是：height: auto ，而在CSS世界中，hright: auto 的值默认是 “0” ，下图中能看到父元素的背景颜色是因为自定义作者样式表中的 padding 属性值为： 1234.container{ padding: 10px; background-color: #161823;} 找出了原因所在，如何解决问题？现在记住这些影响因素，思路也会渐渐变得清晰，还是那句老话 —&gt; “因为找不到常规盒计算高度，所以影响了父元素的高度”；MDN-clear文档也对此问题进行两个标准的解决方案： 给父元素添加一个伪元素::after，然后设置clear: both； 在父元素内部和浮动子元素下方添加块盒进行‘掩盖’。 首先来说第一个方案，给父元素添加一个伪元素::after，然后设置clear: both，添加伪元素众所周知是往该元素内部生成一个不可见的虚拟DOM节点，此元素不进行布局排列，它的重要行为是辅助父元素进行一个规则性的样式调整，🆗，来看图 的确很好的解决了坍塌问题，现在好奇是为什么伪元素设置了 clear: both 就能够让父元素的高度重生呢，那么从代码中找出问题： 12345nav::after{ content: \"\"; //① 伪元素的标记，必须配合此属性才能生成节点 display: block; //② 元素设置成块盒元素 clear: both; //③ 清除属性 该属性值还有类似的： left、right、none} 我们来看②的属性设计，此处很奇怪，在印象中，块盒元素遇到浮动元素不应是无视吗，而为什么这里偏偏需要结合display: block 才能完美呢，而又偏偏是MDN官方给出的方案；我在刚开始也有疑惑过，display: inline-block它不香吗？毕竟行盒对于浮动元素友好，上代码： 12345nav::after{ content: \"\"; display: inline-block; //改了display盒模型，会发生什么？ height: 20px; //此处是给元素添加一个高度，以便查看} 喔~，差点忘记了，拥有行盒属性的布局默认都是跟随在前面罗列元素的右边，从左到右依次排序；那就更印证了官方的方案，我们需要是在下方放置元素，那么肯定有人会想到另一个属性：width: 100% ，听我的，你会多此一举吗？display: block 都已经帮你搞定一切为什么拒绝它呢。回归正题，接下来看一下clear: both 的神秘属性与值，背后的设计原理和设计规则不得而知，但也可以看到此属性的强大之处，当设计clear清除掉浮动属性时，父元素的一切都按照正常执行，使用clear: both的原因是为了防止元素在剩余空间中向上移动；了解它的模式即可，就是为了防止元素在剩余空间中向上移动。 🆗，再看第二个解决方案，在父元素内部和浮动子元素下方添加块盒进行‘掩盖’；怎么理解此话，上代码： 12345678&lt;nav&gt; &lt;li&gt;&lt;a href=\"#\"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;导航&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;产品&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;研发中心&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;联系合作&lt;/a&gt;&lt;/li&gt; &lt;p class=\"clearfix\"&gt;&lt;/p&gt; //此标签元素是添加在浮动元素下方和父元素内部&lt;/nav&gt; 有变化吗？当然有啊，没看到&lt;p&gt;元素已经在结构中了吗（滑稽），开玩笑……，其实这样并不起效果，那怎么才能让该元素“重视”浮动元素，答案是：clear: both ，不像之前那样在父元素内部添加伪元素，并为其设置清除属性，而是直接添加到&lt;p&gt;元素上，上代码： 123.clearfix{ clear: both;} 所有元素都已经按照一切‘规则’渲染，最后，这俩方案采用哪个更合适，以前呢是采用第二套，在内部添加元素并为其设置clear: both；但此方案不好在于影响了结构语义化，因为在导航中，无序列表套装：ul&gt;li，而新增 p 元素没有任何语义，如果仅仅为了解决样式问题，请采用::after方案","link":"/CSS-layou/CSS-clear-%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E5%B1%9E%E6%80%A7/"},{"title":"New page for the blog","text":"首次生成的博客大致是这几天 学习技术 已经很疲惫了，想着来弄一个博客；在以前就关注Hexo开源框架，现在用起来着实不错，配置起来心中一万匹草泥马策马奔腾~~，不过还是蛮有成就感的；后续会不定期更新自己的文章了，flag不高，总应完成吧，那就加油","link":"/HEXO/New-page-for-the-blog/"},{"title":"Vue - 使用 v-for时的重要配合属性（key属性）","text":"在Vue中使用遍历属性时，我们需要给组件或者相对应的标签元素引用 :key 属性，在学习Vue过程中对此问题有着疑惑，查找官方文档发现这是官方推荐用法；但为什么会需要:key 属性结合 v-for 使用？ 这个与Vue的 VDOM （虚拟DOM)提供的Diff算法有着对应的关联； 每个列表项的更新或者删除都被记录在 VNOTE 上，而后操作列表项时VNODE 会与 DOM 比较数据变化。 下图所示： 更新 下图是上列操作的对照，能够大概明白数据的对比更新操作 那看一下官方的介绍： 根据官方的说法，可以得知 :key 是用来给每个节点做一个唯一标识，而在数据更新时Vue会运行 Diff算法 正确识别每个节点，找到正确的定位区域插入新的数据节点。此种方法就是Vue框架一致推崇的性能优化，此属性的作用是为了更高效的更新虚拟DOM。 那 :key 一般绑定数据本身还是索引下标值呢，在众多的文章学习中也是推荐绑定数据本身，但官方是以下标为绑定对象 比如： 1234&lt;p v-for='(item, index) in list' :key='item'&gt; /* :key绑定对象也可以是 index */ {{ item }}&lt;/p&gt; 123456const vm = new Vue({ el: '#app', data: { list: ['javascript', 'python', 'go', 'php'] }})","link":"/VUE/Vue-%E4%BD%BF%E7%94%A8-v-for%E6%97%B6%E7%9A%84%E9%87%8D%E8%A6%81%E9%85%8D%E5%90%88%E5%B1%9E%E6%80%A7%EF%BC%88key%E5%B1%9E%E6%80%A7%EF%BC%89/"},{"title":"图像替换-网站LOGO的实践","text":"京东购物网站的LOGO设计很是巧妙，使用了动态图替换了“死板”的文本，下图中 LOGO 展示位不难发现只有一张图像占位，而打开开发者工具则清楚的看到【京东】两字，为什么京东两字会被‘隐藏’或者说为什么要用图像替换技术呢； 很简单： 京东属于电商网站，文本是对搜索引擎最友好的设计，但过于简单的文本不能真正的满足 LOGO 重要的展示位所以在此基础上用一个图像占位可以更好的发挥网站的目的，而文本标签则负责给爬虫引擎传达信息；所以印证了心中疑惑（为什么不在image 标签使用 alt=”京东” 的属性值）。 如何做到的？这样的设计其实也特别简单，将文本放置 &lt;a&gt; 标签内部，而设计 &lt;a&gt;标签的背景图为网站LOGO，之后使用了一个CSS属性将文本隐藏：font-size: 0; 图像替换方案其实很早就在使用，FIR（Fahrner图像替换）方案属于最早且可能是最流行的图像替换技术，也是最具有意义也是最容易被接受的方案；基本概念与京东网站的方案相似，也是把要替换的文本放在一个标签内部： 12345&lt;h2&gt; &lt;span&gt; 京东 &lt;/span&gt;&lt;/h2&gt; 然后将替换图像作为背景图应用于标题元素： 12345678910h2{ background: url(xxx.jpg) no-repeat; width: 190px; height: 120px;}// 再将span的display值设置为none，从而'隐藏'span的文本内容span{ display: none;} 所以此种技术也是经常出现，但是有一个规则会影响最后的显示问题，有些屏幕阅读器可能会忽略这些设计 display 值为 none 的元素，因此间接影响到文本的显示，而且在网络延迟或者网络响应超时就会一片空白，所以此 ‘bug’ 的影响很大，采用兼容策略时不适合采用此技术方案。 可以将其更换规则，以适应屏幕阅读器的识别： 123&lt;h2&gt; 京东&lt;/h2&gt; 而后不再使用 display 属性来操作文本的显示，而是对标签应用一个非常大的负值文本缩进： 123456h2{ text-indent: -9999px; //值完全自定义 background: url(xxx.jpg) no-repeat; width: 190px; height: 120px;} 这个方案效果很好，解决了屏幕阅读的问题。","link":"/CSS-layou/%E5%9B%BE%E5%83%8F%E6%9B%BF%E6%8D%A2-%E7%BD%91%E7%AB%99LOGO%E7%9A%84%E5%AE%9E%E8%B7%B5/"},{"title":"javascript - Number()类型转换","text":"学习javascript，经常会遇到一些小小的细节问题，在自己有时间也会去研究一下这其中的执行方（tao）式（lu）； Number()强制类型转换是JavaScript中基础的语法，当初并没有去剖析执行的所以然，只知道默认结果即可，但后来回看发现自己的理解有点出入（脑筋不够用），强制类型转换有多种，类似于Number()的：parseInt（），但偏偏Number()在对输入值转换后返回的结果与parseInt()不同；那么，在了解Number()之前必须将类型转换概念的转换原理捋清。 先来认识隐式类型转换，此处只谈 Number类型 ； 隐式类型转换：隐藏式调用背后的转换规则对值进行转换。 怎么理解转换规则，现在对number类型进行剖析，隐式类型转换是通过符号背后调用Number()，比如： ‘*’（乘法）、‘/’（除法），当在一个表达式中对两边的运算进行乘积或除法计算，就会默认调取Number()函数： 看到返回结果是NaN，是因为调用Number()函数返回的结果，非数字类不可转换成对应的数字（16进制除外，如：0x17转换成23） 调用对象自身的valueOf方法: 若返回原始类型值，则直接对该值使用Number函数，不再进行后续步骤; 如果valueOf方法返回的是对象，则调用对象自身的toString方法。若toString方法返回原始类型的值，则对该值使用Number函数，不再进行后续步骤; 如果toString方法返回的是对象，就报错。 其实Number()背后的执行原理很复杂，我用一个比较简单的代码段实现基本的逻辑（不考虑性能与其他因素，只实现相关算法）： 1234567891011121314151617181920212223242526function FINALNUMBER(mixi){ var ARRAR2NUMBER = []; if(typeof(mixi) === \"string\"){ var len = mixi.length; for(let i = 0; i &lt; len; i++){ if(mixi[i] * 1 == mixi[i]){ ARRAR2NUMBER.push(mixi[i]); }else{ return 'NAN - 不能转换'; } } }else if(typeof(mixi) === \"number\"){ return mixi; }else if(typeof(mixi) === \"boolean\"){ if(mixi == true){ return 1 }else { return 0 } } return ARRAR2NUMBER.join('') * 1; } 代码中封装一个 FINALNUMBER() 函数，用来承载输入值，mixi 作为参数传递；随后在内部声明了一个空数组（后续用来接收迭代循环得到的数据项）。 然后看这段代码： 123if(typeof(mixi) === \"string\"){ // 执行体} typeof(mixi)是对函数的参数进行类型检查，满足检查值为 &quot;string&quot; 的进入执行体，后再进行一系列的声明与判断，循序渐进的看 if 的执行体内部： 12345678var len = mixi.length; //①for(let i = 0; i &lt; len; i++){ // ② if(mixi[i] * 1 == mixi[i]){ ARRAR2NUMBER.push(mixi[i]); }else{ return 'NAN - 不能转换'; }} ①：声明len变量接收参数的长度（由于是多次循环，每次都要检测参数长度是一个耗费性能的冗余代码） ②：进行for循环，遍历len，接下来看for循环内部的判断语句： 12345if(mixi[i] * 1 == mixi[i]){ ARRAR2NUMBER.push(mixi[i]);}else{ return 'NAN - 不能转换';} 关键点在：mixi[i] * 1 == mixi[i] 这段代码起什么作用？mixi[i]理解，（* 1）理解， == mixi[i]也能理解，但总结起来就感觉不一样呢？ 接下来好好说说 =&gt; mixi[i]其实是传入值的长度之一，不了解的可再次阅读String函数对象的属性 .length；那么mixi[i] * 1是有什么潜规则吗？答案就是在此强制对mixi[i]的值进行类型转换，上面提到（*，/）两个符号均可调用Number()函数（WTF????此文章不是讲解Number()函数的实现原理吗，怎么绕来绕去又回到这里） 对，讲解原理，但不是覆盖原理，我只是将Number理解到更深一点；回到代码： 12345ARRAR2NUMBER.push(mixi[i]);---------------------------else{ return 'NAN - 不能转换';} 然后对每一个字符节进行检查，满足 mixi[i] * 1后得到的是数字，就调用数组push()方法插入每一项，不符合就进入else，此处起到拦截作用，只要有一个字符不符合，就会影响整个转换规则，最终只返回'NAN - 不能转换' 继续，对于类型为string的结果已经清楚，那么看对于number、boolean类型的如何转换，看代码： 123456789else if(typeof(mixi) === \"number\"){ return mixi;}else if(typeof(mixi) === \"boolean\"){ if(mixi == true){ return 1 }else { return 0 }} 第一：值类型为number的直接返回当前输入值（mixi） 第二：值类型为boolean的，再进行判断true or false，最终结果也可得出。 还有一段代码是对输出结果进行过滤，后面 *1 也是对结果进行类型转换，返回的是数字 1return ARRAR2NUMBER.join('') * 1; 其实还有更好理解的方式，但我只能简单理解到这一步，若有更深的见解请留言","link":"/javascript/javascript-Number-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"title":"Virtual-DOM VS DOM","text":"虚拟DOM的概述 （Virtual DOM）:理解起来非常简单，是使用javascript中的对象结构对DOM进行抽象化，虚拟DOM的优势在于性能提升，网站结构越复杂就越显得重要，真实DOM的性能开销是前所未有的，现如今的MVVM框架改变这一现状，解决了试图和状态的同步问题。 虚拟DOM的出现究竟是为了什么？从开发过程中，不难发现很多DOM操作是需要复杂的计算，网页的渲染最讲究性能内存，Virtual DOM的渲染很友好，特别是对于一些状态更新作出的最优调整变化，它的好处是当状态发生改变时不立即更新DOM，只需要创建一个虚拟树（Virtual Tree）来描述DOM结构，Virtual DOM内部将通过(diff)算法有效的更新DOM，但也不是所有的DOM操作都需要使用Virtual DOM配合，因为是在涉及比较复杂的业务时，才能感觉到差异。 上一篇文章也讲解了VUE当中的v-for循环指令配套属性 key的重要性，就是提升性能的原因所在。 下面是使用 jQuery 操作DOM演示代码 123456789101112&lt;div class=\"container\"&gt; &lt;div class=\"left\"&gt; &lt;button style=\"cursor: pointer;\" type=\"button\" name=\"button\" class=\"btn success\" id=\"BTNADD\"&gt;添加数据&lt;/button&gt; &lt;/div&gt; &lt;div class=\"context\"&gt; &lt;ul id=\"data\"&gt; &lt;li class=\"tr1\"&gt; 实例数据 --- DOM &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213let Dom = ` &lt;li class=\"tr success\"&gt; 新增的数据 --- DOM &lt;button type=\"button\" style=\"cursor: pointer;\" name=\"button\" class=\"del BTNROMVE\"&gt;删除数据&lt;/button&gt; &lt;/li&gt;`$('#BTNADD').click(function(){ setTimeout(function(){ $('#data').append(Dom) $('.tr').animate({ opacity: 1, lineHeight: '44px' },800,) }, 1000)}) 示例中，利用 jQuery API 简单操作了DOM节点，当中用到了插入API以及动画更新DOM树，其实在操作DOM结构时发生了一系列的重建，重建过程就是重新构建DOM树并再次渲染；现在的高级浏览器大部分针对性能作出了优化，但这也不影响DOM操作对网页进行了“重排重绘”： 1$('.tr').animate({ opacity: 1, lineHeight: '44px' },800,) 重排重绘又是怎么一回事？ 看看解释：当页面在浏览器下载完成后，被解析并生成两个内部数据结构 DOM树 表示页面节点结构 渲染树 表示DOM节点显示样式 浏览器主要作用就是用户输入的URL转变成可视化图像，网页加载过程就是从URL到构建DOM树；再到网页渲染过程，从DOM树生成可视化图像。这两个过程可能也会相互影响。 而DOM树中的每一个需要显示的节点在渲染树中至少存在一个对应的节点。渲染树中的节点被称为“行”或“盒”，CSS模型定义，理解页面的元素为一个具体内边距、外边距、边框和位置的盒子。一旦DOM树和渲染树构建完成，浏览器环境就开始绘制元素了。此时，若对DOM树进行操作，修改了元素的宽高、边框宽度、新增文字等等过程，页面就需要重新计算元素的几何属性，其他元素的一切也受到影响。浏览器会使渲染树中受到影响的那一部分失效，并重新构造渲染树。此过程被称作“重排”，完成后，再次重新绘制受影响的部分到页面，就是所谓的“重绘”。操作DOM会让渲染工程“加重”，浏览器会重新计算布局属性，进而重新生成一张新的页面，如下图的简单描述： 先了解一下DOM的实现原理与过程： (摘录：高性能JS) 用脚本对DOM进行操作的代价很昂贵，尽管DOM是个与语言无关的API，但它在浏览器中的接口却是JavaScript实现的；浏览器内核通常将DOM和JavaScript独立实现，如：Safari的DOM和UI渲染是使用Webkit中的WebCore实现，JavaScript部分是由独立的JavaScriptCore引擎来实现；Google Chrome 同样使用Webkit中的WebCore库渲染页面，JavaScript引擎是V8。这对性能的过分依赖造成的结果就是因为两个相互独立的功能需要通过接口彼此连接… 对于创建一个真实的DOM节点，耗费的“成本”颇高；每个节点有自己默认的属性值，下面来看一下DOM节点的属性遍历： 123&lt;div class=\"container\"&gt; // 子节点内容区域&lt;/div&gt; 12345678var $el = $('.container');let value = '';for (var key in $el) { value += key + ','}console.log(value); 对自创建的DOM节点 [class=&quot;container&quot;] 进行属性遍历，打印如下： 10,length,prevObject,jquery,constructor,toArray,get,pushStack,each,map,slice,first,last,eq,end,push,sort,splice,extend,find,filter,not,is,init,has,closest,index,add,addBack,parent,parents,parentsUntil,next,prev,nextAll,prevAll,nextUntil,prevUntil,siblings,children,contents,ready,data,removeData,queue,dequeue,clearQueue,promise,show,hide,toggle,on,one,off,detach,remove,text,append,prepend,before,after,empty,clone,html,replaceWith,appendTo,prependTo,insertBefore,insertAfter,replaceAll,css,fadeTo,animate,stop,finish,slideDown,slideUp,slideToggle,fadeIn,fadeOut,fadeToggle,delay,attr,removeAttr,prop,removeProp,addClass,removeClass,toggleClass,hasClass,val,trigger,triggerHandler,serialize,serializeArray,wrapAll,wrapInner,wrap,unwrap,load,ajaxStart,ajaxStop,ajaxComplete,ajaxError,ajaxSuccess,ajaxSend,offset,position,offsetParent,scrollLeft,scrollTop,innerHeight,height,outerHeight,innerWidth,width,outerWidth,blur,focus,focusin,focusout,resize,scroll,click,dblclick,mousedown,mouseup,mousemove,mouseover,mouseout,mouseenter,mouseleave,change,select,submit,keydown,keypress,keyup,contextmenu,hover,bind,unbind,delegate,undelegate, 足以见解到DOM节点的创建是那么的“费劲”。 然后看看VUE的示例代码 12345678910111213141516171819&lt;div id=\"app\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"flex\"&gt; &lt;label&gt; &lt;input type=\"text\" placeholder=\"name\" v-model='name'&gt; &lt;/label&gt; &lt;/div&gt; &lt;div class=\"content-button\"&gt; &lt;button type=\"button\" :style='disable' @click='add'&gt;添加&lt;/button&gt; &lt;button type=\"button\" @click='remove'&gt;删除&lt;/button&gt; &lt;/div&gt; &lt;transition-group tag='ul' appear&gt; &lt;li v-for=\"item in list\" :key='item.name'&gt; &lt;span class=\"name\" v-text='item.name'&gt;&lt;/span&gt; &lt;/li&gt; &lt;/transition-group&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829new Vue({ data: { name: '', message: '', disable: false, list: [ { name: 'Andy'}, { name: 'Job'} ] }, methods: { add(){ if(this.name == ''){ this.message = '空字符' this.list == this.list }else if(this.name != ''){ this.message = '' this.list.unshift({ name: this.name }) } this.name = '' }, remove(){ this.list.splice(this.list.length - 1,1) } }, render: h =&gt; (App)}).$mount('#app'); 代码好像并没有操作DOM节点，为什么可以做到状态更新，而且也看不出任何与原生操作DOM节点代码的不同。虚拟DOM与原生DOM不同之处就在于对象，我们通过new一个虚拟对象出来代替DOM，内部只实现了两个方法，add()与remove() 123456789101112131415add(){ if(this.name == ''){ this.message = '空字符' this.list == this.list }else if(this.name != ''){ this.message = '' this.list.unshift({ name: this.name }) } this.name = ''}, remove(){ this.list.splice(this.list.length - 1,1) } 原理很简单，对比对象前后状态的变化，如有发生数据不匹配则更新对象，状态更新时不是将所有的数据进行重构，而是在原有的基础上补充，否则保持原有状态；可以理解成一个对象保存着一个引用地址，无论如何变化只在源地址上进行更新不开辟新的内存空间，这就是Virtual DOM的好处 下面是 GitHub 上的项目对Virtual DOM的讲解： 对于Virtual DOM的实现原理，往后学习到更多知识再进行补充（能够持续学习是一种态度，但不保证自己真的能学到很多，此过程很漫长，也很枯燥，希望能带来好运）","link":"/VUE/Virtual-DOM-VS-DOM/"}],"tags":[{"name":"CSS-clear","slug":"CSS-clear","link":"/tags/CSS-clear/"},{"name":"New-Blog","slug":"New-Blog","link":"/tags/New-Blog/"},{"name":"Vue(v-for)","slug":"Vue-v-for","link":"/tags/Vue-v-for/"},{"name":"图像替换","slug":"图像替换","link":"/tags/%E5%9B%BE%E5%83%8F%E6%9B%BF%E6%8D%A2/"},{"name":"javascript - Number()","slug":"javascript-Number","link":"/tags/javascript-Number/"},{"name":"VUE-VNode","slug":"VUE-VNode","link":"/tags/VUE-VNode/"}],"categories":[{"name":"CSS-layou","slug":"CSS-layou","link":"/categories/CSS-layou/"},{"name":"HEXO","slug":"HEXO","link":"/categories/HEXO/"},{"name":"VUE","slug":"VUE","link":"/categories/VUE/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"}]}